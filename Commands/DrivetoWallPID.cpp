// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "DrivetoWallPID.h"
#include <math.h>
DrivetoWallPID::DrivetoWallPID()
{
   printf("In Turn Right Constructor\n");
   // Use requires() here to declare subsystem dependencies
   // eg. requires(chassis);
   // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
   // initialize PID controller
   // Note: There is no range of the input because there is no min/max range of the gyro.
   // and setting the range of the output is unnesscesary because it defaults to -1 to 1.
   m_PIDcontroller = new PIDController(0.0, 0.0, 0.0, Robot::drivetrain->ultrasonicSensor, Robot::drivetrain);
   
   // Set the threshold for the PID controller
   SetThreshold(STOPPING_THRESHOLD);
   
   // The controller is not in range.
   m_inRange = false;
   
   // Create the timer for in range checking
   m_timer = new Timer;
}
// Called just before this Command runs the first time
void DrivetoWallPID::Initialize()
{
   // set the PID gain for the controller
   m_PIDcontroller->SetPID(m_Pgain, m_Igain, m_Dgain);
   
   // The controller is not in range.
   m_inRange = false;
     
   // ensure the timer is stopped (used to ensure in range for specified time)
   m_timer->Stop();
   m_timer->Reset();
   
   // read gyro angle
   m_setPoint = STOPPING_DISTANCE;
   
   // tell the PID controller to 1target angle
   m_PIDcontroller->SetSetpoint(m_setPoint);
   
   // run the PID controller
   m_PIDcontroller->Enable();
}
// Called repeatedly when this Command is scheduled to run
void DrivetoWallPID::Execute() 
{
   // do nothing since PID is running in its own thread
   
   // show the turn angle error
   SmartDashboard::PutNumber("PID Error", GetPIDError());
}
// Make this return true when this Command no longer needs to run execute()
bool DrivetoWallPID::IsFinished() 
{
	
	//TODO 
	return false;
	
}
// Called once after isFinished returns true
void DrivetoWallPID::End() 
{
   // stop the PID 
	m_PIDcontroller->Disable();
	
	// Stop the timer
	m_timer->Stop();
	m_timer->Reset();
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DrivetoWallPID::Interrupted() 
{
   // call the end method
   End();
}
// Get the error between the target setpoint and the actual location
float DrivetoWallPID::GetPIDError()
{
  return m_setPoint - Robot::drivetrain->GetDistance();
}
// Check to see if the position is on target.
bool DrivetoWallPID::IsOnTarget()
{
   return fabs(GetPIDError()) < m_threshold;
}
// Set the Threshold to be considered on target.
void DrivetoWallPID::SetThreshold(float threshold)
{
   m_threshold = threshold;
}
// Set the PID values of the controller
void DrivetoWallPID::SetPID(float p, float i, float d)
{
   m_Pgain = p;
   m_Igain = i;
   m_Dgain = d;
   printf("Set PID %f, %f, %f\n", m_Pgain, m_Igain, m_Dgain);
   m_PIDcontroller->SetPID(m_Pgain, m_Igain, m_Dgain);
}
// Delete the PID controller when the class destructs.
DrivetoWallPID::~DrivetoWallPID()
{
   delete m_PIDcontroller;
}
